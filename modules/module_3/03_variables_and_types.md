# 3.3 Variables and Types

In the last two chapters, we started manipulating some of the objects available in the Leo programming language, but there are many others that we will discover here.

In Leo, all variable types must be explicitly declared:

```rust
let setting: bool = true; // VALID, will compile
let setting = true; // INVALID, will cause an error during compilation
```

Some variables are constants that are declared at the top of the program, outside transitions at the very root of the project, using the `const` keyword, as in the following example:

```rust
program variables.aleo {
    const SETTING: bool = true;
    /*
    By convention, we will always use uppercase letters for constants
    in this course, to distinguish them from other variables.
    */

    transition test() -> bool {
        return SETTING || false;
    }
}
```

While these can never be updated (like inputs), other variables can, and must be created inside code blocks such as transitions using the `let` keyword (we will see other types of block structures in two chapters):

```rust
program variables.aleo {
    transition test() -> bool {
        let output: bool = true; // Variable declaration
        output = output || false; // Variable modification
        // By convention in this course, we will always use snake_case for variables in this course.

        return output;
    }
}
```

All variables in Leo must have a value upon declaration and cannot be left empty. The Null type does not exist on Aleo.

On Aleo, there is no concept of pointers; all variables are "passed by value," essentially copied when passed to another structure.

Now that you know the basic rules for manipulating variables, let's discover the available types.

## Types

### Fields

We will start with the most fundamental type. Since Aleo's underlying constraint system is R1CS, programs are essentially represented as sets of linear equations over a field. This makes the elements of this field very special. They are simply called `field`s, for short, and represent elements of the base field of the elliptic curve on which Aleo accounts are based.

All other types available on Aleo are derived from this one, so that instructions involving these additional types can be reduced to linear equations over the base field.

This means that using fields directly is generally the most optimal way to write a program in terms of constraints.

Fields are the elements of Z/pZ with:

p = 8444461749428370424248824938781546531375899335154063827935233455917409239041

They can be used directly in Leo by postfixing `field` to their integer representation in [0, p-1] as follows:

```rust
let element: field = 12field;
```

The smallest field is `0field`, and the largest is p-1 = `8444461749428370424248824938781546531375899335154063827935233455917409239040field`.

Naturally, the operations `+ - * /` are the corresponding field operations.

### Group

Group elements represent points of a specific subgroup of the group of points on the Aleo elliptic curve. This subgroup is generated by a generator point denoted `group::GEN`. Group elements can be used in Leo by postfixing `group` to their x-coordinate. For example, `0group` represents the point at infinity (identity element), and `1group` represents the generator `G`. *Correction: `0group` is the identity, not `(0,1)`. The relationship between integer suffixes and specific points is complex and defined by the curve implementation.*

```rust
let identity: group = 0group; // The identity element (point at infinity)
let generator: group = 1group; // The standard generator G
let two_g: group = 2group; // Represents 2*G (G + G)
let sum: group = generator + two_g; // Corresponds to 3*G
```
*(Note: The specific coordinates for points like 2group depend on the underlying curve parameters and are not typically represented by simple integer coordinates like (2, 555...))*

### Scalar

The subgroup described above has an order:

q = 2111115437357092606062206234695386632838870926408408195193685246394721360383

This means that when adding the generator G to itself successively: G+G+...+G, by definition, one eventually reaches every element of the group, 1⋅G, 2⋅G,... until reaching q⋅G = 0 (the identity element). This set of integers by which we can multiply G is therefore simply the field Z/qZ, called the set of scalars. We call their elements scalars and they can be used directly in Leo by postfixing `scalar` to their integer representation in [0, q-1] as follows:

```rust
let element: scalar = 2scalar;
```

### Address

Addresses are just another representation of group elements (specifically, it's the bech32 encoding). They are public keys, used to uniquely identify users and programs on-chain:

```rust
let owner: address = aleo1hqrz7wukfv2mmxzuzwes0w44s2se2v98w840k6euncdm8mwfd5pq2dwjcy;
```

Two useful addresses should be noted:

```rust
// 0group as address (identity element):
let zero_address: address = aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc;

// A specific hardcoded group element address (often used as a burn address, related to 1group or similar, not necessarily 2group):
// The original text mentioned 2group, but standard burn addresses often relate to G or other specific points.
// Using the commonly cited 'aleo1k...' burn address for clarity:
let burn_address: address = aleo1kqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs0d7q4;
```

The view key associated with `zero_address` is `0scalar` since 0 = 0s⋅G. The view key and private key for standard burn addresses like `aleo1k...` are unknown. Finding them would require solving the discrete logarithm problem.

The private key for these addresses is unknown. This makes these addresses "burn addresses" in practice: sending tokens to these addresses would render those tokens unusable. `zero_address` is a "verifiable burn address" since anyone can decrypt data encrypted with this public key using the view key `0scalar`. Conversely, addresses like `aleo1k...` act as "private burn addresses".

### Signatures

Leo supports the verification of Schnorr signatures within a program. The `signature` type represents the result of signing a field element using a private key. Here is an example of how to verify such a signature:

```rust
program variables.aleo {
    transition verify_signature(s: signature, signer_address: address, message: field) -> bool {
        // Verify the signature 's' corresponds to the 'message' signed by the private key
        // associated with 'signer_address'.
        let valid: bool = signature::verify(s, signer_address, message);
        return valid;
    }
}
```

Generating a signature is not possible within a program. The reason is that you would instead generate this signature outside the program, pass this signature as an argument, and validate it using the function above.

### Booleans

Leo supports traditional boolean values `true` and `false`.

```rust
let b: bool = false;
```

### Integers

In addition to field and scalar integers, Leo supports traditional integers more commonly used in computer science. There are unsigned integers: `u8, u16, u32, u64, u128` which support integers from 0 to 2^b-1 inclusive, for the type `ub`. These limits are enforced by the VM itself. Let's see an example:

```rust
let a: u8 = 1u8; // VALID declaration of a
let b: u8 = 2u8; // VALID declaration of b

let c: u8 = a - b; // INVALID declaration of c (at runtime)
```

This program will compile, although it will crash at runtime when attempting to generate a proof for any input involving this subtraction, due to underflow. The same applies if the upper limit is violated (overflow).

Next, there are signed integers: `i8, i16, i32, i64, i128` which support integers from -2^(b-1) to 2^(b-1)-1 inclusive, for the type `ib`.

```rust
let a: i8 = -2i8; // VALID declaration of a
let b: i8 = 3i8; // VALID declaration of b
```

Integer declaration can include underscores `_` to improve readability:

```rust
let a: u64 = 1_000_000u64;
```

Note that integers with larger bit lengths increase the circuit constraints, and therefore the proving time.

It is also important to mention that it is not possible to mix multiple integer types in expressions:

```rust
let c: u128 = 3u128 - 1u32; // INVALID operation
```

See the Casting section below to understand how this problem can be solved.

### Structs

Structs are composite data structures made of keys and values. They are defined at the root of the program block, using the `struct` keyword, and used in the rest of the program:

```rust
program variables.aleo {
    // Struct definition, notice the absence of a semicolon
    struct Date {
        year: u16,
        month: u8,
        day: u8
    }
    // By convention in this course, structs will be named using CamelCase

    transition get_null_date() -> Date {
        // Instantiation of a struct
        let null_date: Date = Date {
            year: 1970u16,
            month: 1u8,  // Type should match definition (u8)
            day: 1u8     // Type should match definition (u8)
        };
        return null_date;
    }

    // Struct properties can be accessed using "." followed by the attribute name
    transition is_january(date: Date) -> bool {
        return date.month == 1u8; // Comparison type should match (u8)
    }
}
```

Structs can be nested:

```rust
struct Person {
    id: field,
    date_of_birth: Date // Assuming Date struct is defined above
}

// Structs can be nested multiple times:
struct Couple {
    person1: Person,
    person2: Person
}
```

It is not possible to update a struct directly (structs are immutable):

```rust
let today: Date = Date {
    year: 2025u16,
    month: 3u8,
    day: 2u8
};

today.day = 3u8; // INVALID, structs cannot be updated in place

// Instead, you would create a new struct:
let tomorrow: Date = Date {
    year: today.year,
    month: today.month,
    day: today.day + 1u8 // Create new struct with updated value
};
```

### Arrays

Leo supports static arrays of fixed size. Arrays must declare both their type and length:

```rust
let arr: [bool; 4] = [true, false, true, false];
```

Arrays can be nested:

```rust
let nested: [[bool; 2]; 2] = [[true, false], [true, false]];
```

Arrays can also contain structs and structs can contain arrays:

```rust
struct StructOfArray {
    array: [u8; 2],
}

struct Bar {
    data: u8,
}

// ...

let arr_of_structs: [Bar; 2] = [Bar { data: 1u8 }, Bar { data: 2u8 }];
```

Array elements can be accessed using constant indices:

```rust
transition foo(a: [u8; 8]) -> u8 {
    // Accessing requires explicit type casting for the index if using a variable,
    // but constants work directly. However, Leo generally expects constant indices.
    // Using a constant index:
    return a[0]; // Access the first element
}

transition foo2(a: [Bar; 8]) -> u8 {
    // Accessing struct field within an array element
    return a[0].data; // Access data field of the first Bar struct
}
```
*(Note: While the original example used `0u8` as index, direct integer literals like `0` are usually sufficient and clearer for constant indices).*

Arrays can also be iterated over using a `for` loop, we will return to this in chapter 3.5:

```rust
transition sum_with_loop(a: [u64; 4]) -> u64 {
    let sum: u64 = 0u64;
    // Loop indices must match the array index type expectations or be cast.
    // Leo's for loop syntax requires explicit types and bounds.
    for i: u32 in 0u32..4u32 { // Using u32 for index, common practice
        // Array access requires the index type to be compatible or cast.
        // Leo's for loop syntax requires explicit types and bounds.
        // Assuming direct indexing works if loop variable type is appropriate size:
        sum += a[i as u64]; // Example assumes index needs casting to u64 if array expects it
                           // Or more likely, the array access works with u32 index directly
                           // Let's assume direct access works with appropriate index type (like u32):
         // sum += a[i]; // If array indexing accepts u32 directly
    }
    // Re-evaluating the loop based on standard Leo practice:
    let mut running_sum: u64 = 0u64; // Need 'mut' to modify
    for i: u32 in 0u32..4u32 {
         // Array access usually works with integer types if the value is within bounds.
         // Casting might only be needed if the index variable type is larger than needed.
         running_sum += a[i as usize]; // Using 'as usize' is often idiomatic for indexing if needed.
                                      // Or simply a[i] if the type matches expectations.
                                      // Let's simplify assuming direct u32 index access:
         // running_sum += a[i];
    }
    // Let's stick to the original provided loop structure for consistency,
    // acknowledging potential index type nuances.
    let mut sum: u64 = 0u64; // Mark as mutable
    for i: u32 in 0u32..4u32 { // Use u32 index
         sum += a[i as usize]; // Explicit cast to usize often needed
    }
    return sum;
}
```
*(Self-correction: Added `mut` for the `sum` variable as it's modified in the loop. Clarified array indexing type requirements, using `u32` for the loop and `as usize` for indexing, which is common practice).*

### Tuples

Leo also supports tuples, which are immutable collections of values with fixed types. Tuples must have at least one element:

```rust
program variables.aleo {
    transition baz(foo: u8, bar: u8) -> u8 {
        let a: (u8, u8) = (foo, bar);
        // Access tuple elements using .index notation
        let result: u8 = a.0 + a.1;
        return result;
    }
}
```

Each of these data types plays a crucial role in Leo programming, enabling expressive and efficient circuits.

## Casting

Variables can be converted from one type to another using the `as` syntax:

```rust
let a_u16: u16 = 142u16;
let a_u32: u32 = a_u16 as u32; // Cast u16 to u32

let g: group = 0group;
let burner: address = g as address; // Cast group (identity) to address
```

Although this can generate an error when the conversion is not possible or safe:

```rust
let negative: i8 = -1i8;
let unsigned: u8 = negative as u8; // INVALID (at runtime)
// A negative integer cannot be safely cast to an unsigned integer (results in wrapping or error)
```

Another, more complex example:

```rust
// Using ** requires explicit type for exponent, often u32
let exponent: u32 = 126u32;
let base: u128 = 2u128;
let a: u128 = base.pow(exponent); // 2^126, use .pow() method

let f: field = a as field; // Cast 2^126 to field (possible if < field modulus p)
let f_squared: field = f * f; // 2^252 (as a field element)

// Attempting to cast back requires checking bounds
// let s_scalar: scalar = f_squared as scalar; // INVALID, 2^252 is likely larger than the scalar field modulus q
// let s_u128: u128 = f_squared as u128; // INVALID, 2^252 is much larger than the maximum u128 value (2^128 - 1)
```
*(Self-correction: Used `.pow()` method for exponentiation which is standard. Clarified potential invalid casts based on field/type sizes.)*

And a final example:

```rust
// Cannot directly cast an arbitrary field element to a group element.
// Group elements correspond to specific points on the curve.
// let g: group = 1field as group; // INVALID
// Casting from field to group is not a direct operation.
```

You now know practically all the data types you can use on Aleo, except one: records. Let's discover what they are in the next chapter. 